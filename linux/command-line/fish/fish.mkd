<!-- fish -->
\pagebreak

Setup <!-- {{{1 -->
=====
### set fish as the default system shell in fish
    chsh -s (which fish)

### configuration entry point
    vim ~/.config/fish/config.fish

### sourcing
    source ~/git/dot-files/fish/3fishrc-root-macbook

### disable svn for good
    function svn
    end

\pagebreak

Fish-specific keyboard shortcuts <!-- {{{1 -->
================================
`<c-f>` same as right arrow key, to accept auto-suggestions or move right

`<c-b>` same as left arrow key

`<c-p>` same as upper arrow key

`<c-n>` same as lower arrow key

`<c-l>` or `<command-r> on mac` clean screen better than **clear**

`<c-i>` same as `<tab>`

`bind` see all fish command line shortcuts

`help` to open fish help document

\pagebreak

If statement <!-- {{{1 -->
============
Check an environment variable <!-- {{{2 -->
-----------------------------

    set -xU I_AM_TRUE 1
    if test -n "$I_AM_TRUE"
      echo "now you see me"
    end
    if test -n "$I_AM_FALSE"
      echo "now you don't"
    end
    # now you see me

Check function argument empty <!-- {{{2 -->
-----------------------------

    function a
      if test -n "$argv"
        echo 'the arguments are' $argv
      else
        echo 'no argument found'
      end
    end
    a
    # no argument found
    a some arguments
    # the arguments are some arguments

Do something only when directory contains certain file <!-- {{{2 -->
------------------------------------------------------
    ls *.foo # might yell error, not graceful

    set foos *.foo
    if count $foos >/dev/null
      ls $foos
    end # gracefully noop if no file are found, because count won't throw an error

\pagebreak

For loop <!-- {{{1 -->
========
    for i in *.jpg
      cp $i (basename $i .jpg)-1.jpg
    end # creates a copy for each .jpg file

    for i in */
      zip -r (basename $i).zip $i
    end # zips each directory into its own zip

Do something only when directory contains certain file <!-- {{{2 -->
------------------------------------------------------
    ls *.foo # might yell error, not graceful

    set foos *.foo
    if count $foos >/dev/null
      ls $foos
    end # gracefully noop if no file are found, because count won't throw an error

\pagebreak

For loop <!-- {{{1 -->
========
    for i in *.jpg
      cp $i (basename $i .jpg)-1.jpg
    end # creates a copy for each .jpg file

    for i in */
      zip -r (basename $i).zip $i
    end # zips each directory into its own zip

\pagebreak

Switch statement <!-- {{{1 -->
================

    function showmethedir
      switch $PWD
        case $GITHUB_DIR/learn/learn-linux/command-line/fish
          echo 'this is fish/ directory haha~'
        case $GITHUB_DIR/learn/learn-linux/command-line
          echo 'this is command-line/ directory oh yeah~'
        case '*'
          echo 'I do not recognize this directory'
      end
    end
    cd $GITHUB_DIR/learn/learn-linux/
    showmethedir #I do not recognize this directory
    cd $GITHUB_DIR/learn/learn-linux/command-line
    showmethedir #this is command-line/ directory oh yeah~
    cd $GITHUB_DIR/learn/learn-linux/command-line/fish
    showmethedir #this is fish/ directory haha~

\pagebreak

Functions <!-- {{{1 -->
=========
argv <!-- {{{2 -->
----
`$argv[1]` is the **first** element, not the second.

    function func
      echo $argv[1]+$argv[3]
    end
    func 1 2 3 # 1+3

`$argv` can also be used as a whole.

    function vimvanilla
      vim -u NONE -N $argv
    end
    vimvanilla $GITHUB_DIR/learn/learn-linux/command-line/fish/fish.md +55 #this line

`$argv` concatenation can be tricky. Be careful when `$argv` and a string are adjacent.

`$argv'something'` adds something to the end of every item in `$argv`, while `$argv 'something'`
returns an array with the entirety of `$argv` before `something`.

    function argvConcat
      echo $argv 'and me'
      echo $argv' and me each'
      echo 'everything and' $argv
      echo 'everything each and '$argv
    end
    argvConcat hello world
    # hello world and me
    # hello and me each world and me each
    # everything and hello world
    # everything each and hello everything each and world

Only define undefined functions <!-- {{{2 -->
-------------------------------

    # new definition wins
    function ilikenewdefinition
      echo 'hello world'
    end
    function ilikenewdefinition
      echo 'another definition'
    end
    ilikenewdefinition
    # old definition wins
    type onlydefinemeonce > /dev/null 2>&1; or function onlydefinemeonce
      echo 'hello world'
    end
    type onlydefinemeonce > /dev/null 2>&1; or function onlydefinemeonce
      echo 'you no see me'
    end
    onlydefinemeonce

Explicitly use the built-in version of a command <!-- {{{2 -->
------------------------------------------------
    function ls
      command ls --color=auto $argv
    end

Without adding `command`, an infinite recursion bug will occur. `command` explicitly points to the
built-in version of the command, instead of the new function defined here.

Alias <!-- {{{2 -->
-----
The following are equivalent

    alias rmi "rm -i"

    function rmi
      rm -i $argv
    end

\pagebreak

and, or <!-- {{{1 -->
=======
`and` only runs when the previous command returns true.

`or` only runs when the previous command returns false.

A safer way to cat <!-- {{{2 -->
------------------

    # nasty error message if file not exist
    cat resources/file_that_may_not.exist
    # no error message
    test -s resources/file_that_may_not.exist; and cat resources/file_that_may_not.exist

A safer mv <!-- {{{2 -->
----------

    function asafermvsetup
      echo 'important content' > resources/asafermv
      echo 'new content' > resources/asafermv2
    end
    asafermvsetup
    #
    # the previous content in asafermv is then lost
    mv resources/asafermv2 resources/asafermv
    cat resources/asafermv # new content
    #
    function safermv
      test -s $argv[2]; or mv $argv[1] $argv[2]
    end
    # the previous content in asafermv is preserved
    asafermvsetup
    safermv resources/asafermv2 resources/asafermv
    cat resources/asafermv # important content

##### But of course, the best way is always mv -i which prompts on conflict

    mv -i resources/asafermv2 resources/asafermv

\pagebreak

IO <!-- {{{1 -->
==
Parentheses for evaluation <!-- {{{2 -->
--------------------------
- `vim (grep -r mark * | grep -v 'fish.md:' | cut -f1 -d: | sort -u)` : us vim to open all the files
    returned by the grep command group
- `vim (fs nocolor \/findme\$)` : open all files that has findme in their names
- `vim (ls *.txt)` : open all txt files
- `cat (npm get userconfig)` : show the content of the file that npm get userconfig specifies

Redirection <!-- {{{2 -->
-----------
There are three file descriptors, 0 for standard input, 1 for standard output and 2 for standard
error.

For each there is a redirection mechanism.

- `< a.file` : redirects the content of a.file to the command instead of standard input
- `> a.file` : redirects standard output to a.file. It is the same as `1>`
- `>> a.file` : redirects standard output to append to a.file. It is the same as `1>>`
- `>&-` : close standard output
- `^ a.file` : redirects standard error to a.file. It is the same as `2>`
- `^^ a.file` : redirects standard error to append to a.file. Same as `2>>`
    - `rm -rf /tmp/1; mkdir /tmp ^/tmp/1; mkdir /tmp ^^/tmp/1; cat /tmp/1;` : 2 lines of error
    - `rm -rf /tmp/1; mkdir /tmp 2>/tmp/1; mkdir /tmp 2>>/tmp/1; cat /tmp/1;` : 2 lines of error
- `^&-` : close standard error
  - `mkdir /tmp ^ /dev/null` : shows no error
  - `mkdir /tmp ^&-` : shows no error. `&-` means to close the file discriptor, which was specified
    by `&` to be standard error

Piping <!-- {{{2 -->
------
By default, the vertical bar `|` pipes the standard output of the previous command to the standard
input of the next command. It is possible to explicitly use the standard error of the previous
command instead.

- `mkdir /tmp 2>| less` : pipes standard error to less

\pagebreak

Count <!-- {{{1 -->
=====
Count array <!-- {{{2 -->
-----------
- `count $PATH` : return the number of items inside array $PATH
- `count $argv` : return the number of items in the argument

Count files <!-- {{{2 -->
-----------
When counting files, `count` is almost always used with wildcards. When the result counting is zero,
`count` won't throw an error.

- `count somethingunheardof` : 1
- `count something?unheard*of` : 0
- `count **/*.mkd` : 1
- `count ***.mkd` : 2

\pagebreak

Eval <!-- {{{1 -->
====
`eval` executes a string as a command. This is useful when I want to escape special characters, like
the pipe bar `|`.

    function quickless
      eval $argv "| less"
    end
    quickless ls -al ~
    # same as ls -al ~ | less

\pagebreak

prompt <!-- {{{1 -->
======
Verbose prompt <!-- {{{2 -->
--------------
a prompt that looks like: `tangke@Kirks-MacBook-Pro ~/g/active-notes:master`, or
![](./resources/prompt.png)

    # red for dirty git branches
    set fish_git_dirty_color red
    # green for clean git branches
    set fish_git_not_dirty_color green
    # process git status
    type parse_git_branch > /dev/null 2>&1; or function parse_git_branch
      # define branch name
      set -l branch (git branch 2> /dev/null | grep -e '\* ' | sed 's/^..\(.*\)/\1/')

      # define git_diff (we only care about whether it's empty)
      set -l git_diff (git diff)

      # apply different colors based on whether the git branch is dirty
      if test -n "$git_diff"
        echo (set_color $fish_git_dirty_color)$branch(set_color normal)
      else
        echo (set_color $fish_git_not_dirty_color)$branch(set_color normal)
      end
    end
    function fish_prompt
      set -l git_dir (git rev-parse --git-dir 2> /dev/null)
      if test -n "$git_dir"
        printf '%s@%s %s%s%s:%s> ' (whoami) (hostname|cut -d . -f 1) \
          (set_color $fish_color_cwd) (prompt_pwd) (set_color normal) (parse_git_branch)
      else
        printf '%s@%s %s%s%s> ' (whoami) (hostname|cut -d . -f 1) \
          (set_color $fish_color_cwd) (prompt_pwd) (set_color normal)
      end
    end

Simplified prompt <!-- {{{2 -->
-----------------
a slightly simpler prompt that looks like: `~/g/active-notes:master`, or
![](./resources/simpler-prompt.png)

    # red for dirty git branches
    set fish_git_dirty_color red
    # green for clean git branches
    set fish_git_not_dirty_color green
    # process git status
    type parse_git_branch > /dev/null 2>&1; or function parse_git_branch
      # define branch name
      set -l branch (git branch 2> /dev/null | grep -e '\* ' | sed 's/^..\(.*\)/\1/')

      # define git_diff (we only care about whether it's empty)
      set -l git_diff (git diff)

      # apply different colors based on whether the git branch is dirty
      if test -n "$git_diff"
        echo (set_color $fish_git_dirty_color)$branch(set_color normal)
      else
        echo (set_color $fish_git_not_dirty_color)$branch(set_color normal)
      end
    end
    function fish_prompt
      set -l git_dir (git rev-parse --git-dir 2> /dev/null)
      if test -n "$git_dir"
        printf '%s%s%s:%s> ' (set_color $fish_color_cwd) (prompt_pwd) \
          (set_color normal) (parse_git_branch)
      else
        printf '%s%s%s> ' (set_color $fish_color_cwd) (prompt_pwd) (set_color normal)
      end
    end

\pagebreak

Miscellaneous <!-- {{{1 -->
=============
Wildcard <!-- {{{2 -->
--------
- `**` : matches zero or more characters recursively, including `/`, this is specific to fish
    - `ls ~/git/**/*.xmind`
- `ls -d **` : list every unhidden file and directory. It essentially carries the same information
  as tree but less graphical
- `**/*.fish` : matches all .fish files in subdirectories
    - `ls **/*.mkd` : shows only resources/sample.mkd
- `***.fish` : matches all .fish files in subdirectories as well as PWD
    - `ls ***.mkd` : shows fish.mkd and resources/sample.mkd

Single quotes and double quotes <!-- {{{2 -->
-------------------------------
### Single quotes
Single quotes in fish prevents all expansions.

- `echo '"'` : echoes "
- `echo 'a\bb'` : echoes `a\bb`
    - `echo a\bb` : echoes `b`
- `echo '*???'` : echoes `*???`
    - `echo *???` : echoes all files with at least three-character long file name
- `echo '{yo,lo}'` : echoes `{yo,lo}`
    - `echo {yo,lo}` : echoes `yo lo`
- `set hello gen; echo '$hello'` : echoes `$hello`
    - `set hello gen; echo $hello` : echoes `gen`

### Double quotes
Variable expansion is the only type of expansion that takes effect inside double quotes.

- `echo "'"` : echoes '
- `echo "a\bb"` : echoes `a\bb`
    - `echo a\bb` : echoes `b`
- `echo "*???"` : echoes `*???`
    - `echo *???` : echoes all files with at least three-character long file name
- `echo "{yo,lo}"` : echoes `{yo,lo}`
    - `echo {yo,lo}` : echoes `yo lo`
- `set hello gen; echo "$hello"` : echoes `gen`

Clean up <!-- {{{2 -->
--------
Often times I forget to clean up environment variables that I have created, but they remain there.

To clean them up, go to `~/.config/fish` and delete the file named something like
`fishd.acbc32a4be89`. This is a file automatically generated by fish that has all the environment
variable declaration.

Set <!-- {{{2 -->
---
- `set -l` : locally set a variable to the current block
- `set a 0 1 2 3` : set a to be an array of [0, 1, 2, 3]
