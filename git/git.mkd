<!-- git -->
\pagebreak

Stage <!-- {{{1 -->
=====
- `git add file_or_directory` : stage a single file or directory
    - `git add .`
- `git add -p` : stage one modified page at a time with prompt (does not care about new files). A
  single modified file can have multiple pages.
- `git add --all` : add everything new under the git repository, including new files and files above
  the current directory

\pagebreak

Commit <!-- {{{1 -->
======
- `git commit -a` : only commit modified files, ignoring untracked files
- `git commit --amend` : amend previous commit, meaning to add changes to it without creating a new
  commit
- `git commit -m single_word` : quick commit with a one-word (no whitespace in the middle) message
- `git commit -m 'longer commit message'` : quick commit with a message longer than one word
- `git commit --allow-empty` : allow empty commits, that is, commits that are identical to its
  predecessor

\pagebreak

Rollback <!-- {{{1 -->
========
HEAD <!-- {{{2 -->
----
- HEAD is the latest commit
    - `git diff HEAD` : checks diff against the latest commit, useful when some changes are staged
      but not committed.
- HEAD^ is the one before the latest commit
    - `git diff HEAD HEAD^` : checks the diff between the latest commit and the one before, i.e.
      check what the latest commit was about. Uncommitted changes are ignored.
- HEAD~0 is the same as HEAD
    - `git diff HEAD~0 HEAD` : returns empty
- HEAD~1 is the same as HEAD^
    - `git diff HEAD~1 HEAD^` : returns empty
- HEAD~10 is ten commits before.

Tedious but safe with git checkout <!-- {{{2 -->
----------------------------------
1. `git log`
2. pick a commit, and copy the commit hash
3. `git checkout that_commit_hash`
4. if I do wish to create a branch based on that_commit_hash, `git checkout -b branch_name`
5. if I have made some change and decide to merge that into master,
  `git checkout master; git merge branch_name`
6. otherwise, to return to master, `git checkout master`

Faster but more dangerous with git reset <!-- {{{2 -->
----------------------------------------
1. `git checkout -b branch_name` : crucial, backup first because git reset cannot be undone!
2. `git log`
3. pick a commit, and copy the commit hash
4. `git reset that_commit_hash` : this will reset the staging info to that_commit_hash but won't
   touch any file. What this means is that git will base itself back to the stage of that commit,
   keep all the files intact, and diff the current files against that commit

Fastest but most dangerous with git reset --hard <!-- {{{2 -->
------------------------------------------------
TODO

\pagebreak

Diff <!-- {{{1 -->
====
- `git diff master` : check diff against master. Useful when some changes have been staged but I
  still wish to see their diff (in which case master is the current branch), or when I want to check
  the diff of the current branch against master (in which case I am on a different branch).
- `git diff HEAD` : same as above but better.
- `git diff file1 file2` : check diff between 2 files.

\pagebreak

Config <!-- {{{1 -->
======
- `git config user.name "My Name"` : set the user.name that appears in the commit message to be "My
  Name"
    - `git config --global user.name "My Name"` : do so globally
- `git config user.email "my@mail.address"` : set the user.email that appears in the commit message
  to be "my@mail.address"
-  `git config --global core.ignorecase false` TODO

\pagebreak

Miscellaneous <!-- {{{1 -->
=============
- `git log`
- `git show`
