<!-- vim -->
<p></p>
<h1 id="general-ex-command-line">General ex command line <!-- {{{1 --></h1>
<ul>
<li><code>set {option1} {option2}</code> : issue two set commands (same for setlocal)
<ul>
<li><code>set cursorline! hlsearch!</code></li>
</ul></li>
<li><code>{command1} | {command2}</code> : issue two ex commands in one line
<ul>
<li><code>echo 'hello' | set ruler!</code></li>
</ul></li>
<li><code>exe {string}</code> : run the string as an ex command line
<ul>
<li><code>exe 'set colorcolumn='.(40+20)</code></li>
</ul></li>
<li><code>redraw!</code> : sometimes the vim rendering is corrupted, run this will force vim to redraw</li>
<li><code>q:</code> : opens command history window</li>
<li><code>put =expression</code> : evaluate the expression, paste the result and enter normal mode
<ul>
<li><code>put =1+2</code></li>
</ul></li>
</ul>
<p></p>
<h1 id="editing-in-ex-command-line">Editing in ex command line <!-- {{{1 --></h1>
<ul>
<li><code>&lt;c-r&gt;&lt;c-a&gt;</code> : Pull <CWORD> onto search/command line</li>
<li><code>&lt;c-r&gt;&lt;c-w&gt;</code> : Pull <cword> onto search/command line</li>
<li><code>&lt;c-r&gt;{register}</code> : Pull the content of {register} onto search/command line
<ul>
<li><code>&lt;c-r&gt;/</code> : last search</li>
<li><code>&lt;c-r&gt;:</code> : last ex command</li>
<li><code>&lt;c-r&gt;@</code> : last yanked</li>
<li><code>&lt;c-r&gt;%</code> : file name</li>
</ul></li>
</ul>
<p></p>
<h1 id="vim-shell-interactions">Vim-shell interactions <!-- {{{1 --></h1>
<ul>
<li><code>sh</code> : open a temporary shell, return to vim upon its exit</li>
</ul>
<p></p>
<h1 id="buffer-management">Buffer management <!-- {{{1 --></h1>
<ul>
<li><code>badd {file_name}</code> : add {file-name} to the buffer list without opening it
<ul>
<li><code>badd resources/a</code></li>
</ul></li>
</ul>
<p></p>
<h1 id="file-operation">File operation <!-- {{{1 --></h1>
<ul>
<li><code>:edit!</code> / <code>:e!</code> : reload current buffer from disk</li>
<li><code>:E</code> / <code>:e.</code> / <code>:e .</code> : open the current directory in netrw</li>
<li><code>X</code> : crypt the current file
<ul>
<li><code>e resouces/encryptme</code></li>
<li>write something</li>
<li><code>X</code></li>
</ul></li>
<li><code>:find {pattern}</code> : open the file that matches pattern, if multiple files are present it fails with message <strong>E77: Too many file names</strong>
<ul>
<li><code>find **/*foundm*</code></li>
</ul></li>
<li><code>enew</code> : open a new unnamed buffer</li>
<li><code>vnew</code> : open a new unnamed buffer in the vertical split</li>
<li><code>w {file}</code> / <code>write {file}</code> : save the current buffer to file and remind in the current file
<ul>
<li><code>write! resources/write</code>
<ul>
<li>we are still at vim.md</li>
</ul></li>
</ul></li>
<li><code>w {file}</code> / <code>write {file}</code> : also works with visual selection
<ul>
<li>visually select a chunk</li>
<li><code>write! resources/xwrite</code>
<ul>
<li>we are still at vim.md, with the visually selected piped to the content of xwrite</li>
</ul></li>
</ul></li>
<li><code>sav {file}</code> / <code>saveas {file}</code> : save the current buffer to file and switch to that file, doesn't work with visual selection
<ul>
<li><code>sav resources/saveas</code>
<ul>
<li>we are now at resources/saveas</li>
</ul></li>
</ul></li>
<li><code>r {file}</code> / <code>read {file}</code> : paste the content of {file} here
<ul>
<li><code>read resources/xwrite</code></li>
</ul></li>
<li><code>r! {command}</code> : run shell command {command}, paste the output here
<ul>
<li><code>r!ls -al</code></li>
</ul></li>
<li><code>TOhtml</code> : print the current file (or visual selection) to an html file named <strong>%.html</strong>
<ul>
<li><code>TOhtml</code></li>
<li><code>w resources/vim.md.html</code></li>
<li><code>!open resources/vim.md.html</code></li>
</ul></li>
</ul>
<p></p>
<h1 id="visual-selection-mode">Visual selection mode <!-- {{{1 --></h1>
<ul>
<li><code>g?</code> : turn selected text into gibberish</li>
</ul>
<p></p>
<h1 id="mark">Mark <!-- {{{1 --></h1>
<pre><code>:marks : print the active marks list

ma : place a mark a
&#39;a : move to the ^ of the line of mark a
`a : move to the exact location of mark [a-z]

mA : place a mark A that can be accessed from anywhere
&#39;A : move to the ^ of the line of mark A in any file
`A : move to the exact location of mark A in any file

`. : move to the last edit
&#39;. : move to the ^ of the last edit

`` : position before the last jump within current file
&#39;` : the ^ of position before the last jump within current file

`^ : location of last insertion
&#39;^ : the ^ of last insertion

`[ : start of last change or yank
&#39;[ : the ^ of start of last change or yank

`] : end of last change or yank
&#39;] : the ^ of end of last change or yank

`&lt; : start of last visual selction
&#39;&lt; : the ^ of start of last visual selction

`&gt; : end of last visual selection
&#39;&gt; : the ^ of end of last visual selection</code></pre>
